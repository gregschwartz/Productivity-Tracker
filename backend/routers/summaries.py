"""
CRUD router for weekly summaries with AI generation and search capabilities.
"""
from fastapi import APIRouter, HTTPException, Depends
from typing import List, Optional
import weave
from sqlalchemy.ext.asyncio import AsyncSession

from models.models import Task, WeeklySummary, SummaryRequest
from services.summary_service import SummaryService
from services.ai_service import AIService
from services.task_service import TaskService # Import TaskService
from services.database import get_session # For session dependency

router = APIRouter(prefix="/summaries", tags=["summaries"])

ai_service = AIService()
summary_service = SummaryService()
task_service = TaskService() # Instantiate TaskService

@router.post("/", response_model=WeeklySummary)
@weave.op()
async def generate_summary_route(request: SummaryRequest, db: AsyncSession = Depends(get_session)):
    """Generate a weekly productivity summary using AI and store in vector database."""
    try:
        if not request.tasks:
            raise HTTPException(
                status_code=400,
                detail="No tasks provided for summary generation"
            )
  
        # 1. Generate summary using AI service
        ai_response = await ai_service.generate_weekly_summary(
            tasks=request.tasks,
            week_start=request.week_start,
            week_end=request.week_end,
            week_stats=request.week_stats,
            context_summaries=request.context_summaries
        )
        
        if ai_response.summary == "" or ai_response.recommendations == []:
            raise HTTPException(
                status_code=500,
                detail="Failed to generate summary, AI response is empty"
            )
        
        # 2. Prepare data for storage
        summary_data_to_store = WeeklySummary(
            week_start=request.week_start,
            week_end=request.week_end,
            summary=ai_response.summary,
            stats=request.week_stats.dict(), # Ensure stats is a dict if model expects it
            recommendations=ai_response.recommendations
            # Embedding will be generated by the service method
        )
        
        # 3. Store with vector embedding using SummaryService
        stored_summary = await summary_service.create_weekly_summary(
            session=db,
            summary_data=summary_data_to_store
        )
        
        return stored_summary
        
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        # Log the exception e for debugging
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate summary: {str(e)}"
        )

@router.get("/", response_model=List[WeeklySummary])
@weave.op()
async def get_summaries_route(
    skip: int = 0,
    limit: int = 10,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    db: AsyncSession = Depends(get_session)
):
    """
    Get weekly summaries with optional filtering:
    - No params: paginated list
    - start_date: get summary for specific week
    - start_date + end_date: get summaries in date range
    
    Note: For vector search, use the /search endpoint instead.
    """
    try:
        summaries = await summary_service.get_weekly_summaries(
            session=db,
            skip=skip,
            limit=limit,
            start_date=start_date,
            end_date=end_date
        )
        return summaries
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get summaries: {str(e)}"
        )

@router.get("/search", response_model=List[WeeklySummary])
@weave.op()
async def search_summaries_route(
    query: str,
    db: AsyncSession = Depends(get_session)
):
    """Search for summaries using vector similarity."""
    try:
        summaries = await summary_service.vector_search_week_summaries(session=db, query_text=query, similarity_threshold=0.3)
        return summaries
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to search summaries: {str(e)}"
        )

@router.get("/stats/count", response_model=dict) # Adjusted response_model
@weave.op()
async def get_summary_count_route(db: AsyncSession = Depends(get_session)):
    """Get total count of weekly summaries."""
    try:
        count = await summary_service.get_count_of_summaries(session=db)
        return {"total_summaries": count}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get summary count: {str(e)}")

@router.get("/{summary_id}", response_model=WeeklySummary)
@weave.op()
async def get_summary_by_id_route(summary_id: int, db: AsyncSession = Depends(get_session)):
    """Get a specific weekly summary by ID."""
    try:
        summary = await summary_service.get_weekly_summary_by_id(session=db, summary_id=summary_id)
        if not summary:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return summary
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get summary: {str(e)}")

@router.put("/{summary_id}", response_model=WeeklySummary)
@weave.op()
async def update_summary_route(summary_id: int, summary_data: dict, db: AsyncSession = Depends(get_session)):
    """Update a weekly summary (regenerates embedding if content changed)."""
    try:
        summary = await summary_service.update_weekly_summary(session=db, summary_id=summary_id, summary_data=summary_data)
        if not summary:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return summary
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to update summary: {str(e)}")

@router.delete("/{summary_id}")
@weave.op()
async def delete_summary_route(summary_id: int, db: AsyncSession = Depends(get_session)):
    """Delete a weekly summary."""
    try:
        success = await summary_service.delete_weekly_summary(session=db, summary_id=summary_id)
        if not success:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return {"message": "Weekly summary deleted successfully"}
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to delete summary: {str(e)}")
