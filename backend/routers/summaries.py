"""
CRUD router for weekly summaries with AI generation and search capabilities.
"""
from fastapi import APIRouter, HTTPException, Depends
from typing import List, Optional
import weave
from sqlalchemy.ext.asyncio import AsyncSession

from models.models import WeeklySummary, SummaryRequest
from services.summary_service import SummaryService
from services.ai_service import AIService
from services.task_service import TaskService # Import TaskService
from services.database import get_session # For session dependency

router = APIRouter(prefix="/summaries", tags=["summaries"])

ai_service = AIService()
summary_service = SummaryService()
task_service = TaskService() # Instantiate TaskService

@router.post("/", response_model=WeeklySummary)
@weave.op()
async def generate_summary_route(request: SummaryRequest, db: AsyncSession = Depends(get_session)):
    """Generate a weekly productivity summary using AI and store in vector database."""
    try:
        if not request.tasks:
            raise HTTPException(
                status_code=400,
                detail="No tasks provided for summary generation"
            )
  
        # 1. Generate summary using AI service
        ai_response = await ai_service.generate_weekly_summary(
            tasks=request.tasks,
            week_start=request.week_start,
            week_end=request.week_end,
            week_stats=request.week_stats,
            context_summaries=request.context_summaries
        )
        
        if ai_response.summary == "" or ai_response.recommendations == []:
            raise HTTPException(
                status_code=500,
                detail="Failed to generate summary, AI response is empty"
            )
        
        # 2. Prepare data for storage
        summary_data_to_store = WeeklySummary(
            week_start=request.week_start,
            week_end=request.week_end,
            summary=ai_response.summary,
            stats=request.week_stats.dict(), # Ensure stats is a dict if model expects it
            recommendations=ai_response.recommendations
            # Embedding will be generated by the service method
        )
        
        # 3. Store with vector embedding using SummaryService
        stored_summary = await summary_service.create_weekly_summary(
            session=db,
            summary_data=summary_data_to_store
        )
        
        return stored_summary
        
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        # Log the exception e for debugging
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate summary: {str(e)}"
        )

@router.get("/", response_model=List[WeeklySummary])
@weave.op()
async def get_summaries_route(
    skip: int = 0,
    limit: int = 10,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    query: Optional[str] = None, # This is the search query text
    db: AsyncSession = Depends(get_session)
):
    """
    Get weekly summaries with optional filtering:
    - No params: paginated list
    - start_date: get summary for specific week
    - start_date + end_date: get summaries in date range
    - query: semantic search using vector similarity
    """
    try:
        # The service method get_weekly_summaries now handles the query_text parameter for search
        summaries = await summary_service.get_weekly_summaries(
            session=db,
            skip=skip,
            limit=limit,
            start_date=start_date,
            end_date=end_date,
            query_text=query # Pass the query parameter as query_text
        )
        return summaries
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get summaries: {str(e)}"
        )

@router.get("/{summary_id}", response_model=WeeklySummary)
@weave.op()
async def get_summary_by_id_route(summary_id: int, db: AsyncSession = Depends(get_session)):
    """Get a specific weekly summary by ID."""
    try:
        summary = await summary_service.get_weekly_summary_by_id(session=db, summary_id=summary_id)
        if not summary:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return summary
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get summary: {str(e)}")

@router.put("/{summary_id}", response_model=WeeklySummary)
@weave.op()
async def update_summary_route(summary_id: int, summary_data: dict, db: AsyncSession = Depends(get_session)):
    """Update a weekly summary (regenerates embedding if content changed)."""
    try:
        summary = await summary_service.update_weekly_summary(session=db, summary_id=summary_id, summary_data=summary_data)
        if not summary:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return summary
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to update summary: {str(e)}")

@router.delete("/{summary_id}")
@weave.op()
async def delete_summary_route(summary_id: int, db: AsyncSession = Depends(get_session)):
    """Delete a weekly summary."""
    try:
        success = await summary_service.delete_weekly_summary(session=db, summary_id=summary_id)
        if not success:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return {"message": "Weekly summary deleted successfully"}
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to delete summary: {str(e)}")

@router.get("/stats/count", response_model=dict) # Adjusted response_model
@weave.op()
async def get_summary_count_route(db: AsyncSession = Depends(get_session)):
    """Get total count of weekly summaries."""
    try:
        count = await summary_service.get_count_of_summaries(session=db)
        return {"total_summaries": count}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get summary count: {str(e)}")

@router.post("/analyze-patterns", response_model=dict) # Define a response model if known, or use dict
@weave.op()
async def analyze_task_patterns_route(
    request: SummaryRequest, # Reusing SummaryRequest for its 'tasks' field
    # db: AsyncSession = Depends(get_session) # No DB session needed if tasks are passed directly
):
    """
    Analyzes productivity patterns from a list of provided tasks.
    The tasks are taken from the SummaryRequest model.
    """
    if not request.tasks:
        raise HTTPException(
            status_code=400,
            detail="No tasks provided for pattern analysis."
        )

    try:
        # The analyze_task_patterns method in TaskService expects List[Task]
        # SummaryRequest.tasks is List[Task] (SQLModel objects)
        analysis_results = task_service.analyze_task_patterns(tasks=request.tasks)
        return analysis_results
    except Exception as e:
        # Log the exception e for debugging
        raise HTTPException(
            status_code=500,
            detail=f"Failed to analyze task patterns: {str(e)}"
        )