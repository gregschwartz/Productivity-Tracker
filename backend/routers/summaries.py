"""
CRUD router for weekly summaries with AI generation and search capabilities.
"""
from fastapi import APIRouter, HTTPException, Depends, Request
from typing import List, Optional
import weave
from sqlalchemy.ext.asyncio import AsyncSession

from models.models import Task, WeeklySummary, WeeklySummaryPublic, SummaryRequest, PaginatedSummariesResponse
from services.summary_service import SummaryService
from services.ai_service import AIService
from services.search_service import SearchService
from services.task_service import TaskService
from services.database import get_session
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

router = APIRouter(prefix="/summaries", tags=["summaries"])
limiter = Limiter(key_func=get_remote_address)

ai_service = AIService()
summary_service = SummaryService()
search_service = SearchService()
task_service = TaskService()

@router.post("/", response_model=WeeklySummaryPublic)
@weave.op()
@limiter.limit("10/minute")
async def generate_summary_route(summary_request: SummaryRequest, request: Request, db: AsyncSession = Depends(get_session)):
    """Generate a weekly productivity summary using AI and store in vector database."""
    try:
        if not summary_request.tasks:
            raise HTTPException(
                status_code=400,
                detail="No tasks provided for summary generation"
            )

        # 1. Generate summary using AI service
        ai_response = await ai_service.generate_weekly_summary(
            tasks=summary_request.tasks,
            week_start=summary_request.week_start,
            week_end=summary_request.week_end,
            context_summaries=summary_request.context_summaries
        )
        
        if ai_response.summary == "" or ai_response.recommendations == []:
            raise HTTPException(
                status_code=500,
                detail="Failed to generate summary, AI response is empty"
            )
        
        # 2. Prepare data for storage
        summary_data_to_store = WeeklySummary(
            week_start=summary_request.week_start,
            week_end=summary_request.week_end,
            summary=ai_response.summary,
            stats=summary_request.week_stats.model_dump(), # Ensure stats is a dict if model expects it
            recommendations=ai_response.recommendations
            # Embedding will be generated by the service method
        )
        
        # 3. Store with vector embedding using SummaryService
        stored_summary = await summary_service.create_weekly_summary(
            session=db,
            summary_data=summary_data_to_store
        )
        
        return stored_summary
        
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        # Log the exception e for debugging
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate summary: {str(e)}"
        )

@router.get("/", response_model=PaginatedSummariesResponse)
async def get_summaries_route(
    offset: int = 0,
    limit: int = 100,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    db: AsyncSession = Depends(get_session)
):
    """
    Get weekly summaries with pagination and optional filtering:
    - No params: all summaries
    - start_date: summary for specific week
    - start_date + end_date: summaries in date range (inclusive)
    
    Note: For vector search, use the /search endpoint instead.
    """
    try:
        # Validate pagination parameters
        if limit <= 0 or limit > 100:
            raise HTTPException(status_code=400, detail="Limit must be between 1 and 100")
        if offset < 0:
            raise HTTPException(status_code=400, detail="Offset must be a positive integer")
        
        # Get summaries and total count
        summaries = await summary_service.get_weekly_summaries(
            session=db,
            skip=offset,
            limit=limit,
            start_date=start_date,
            end_date=end_date
        )
        total = await summary_service.get_summaries_count(
            session=db,
            start_date=start_date,
            end_date=end_date
        )
        
        return PaginatedSummariesResponse(
            summaries=summaries,
            total=total,
            limit=limit,
            offset=offset,
            has_more=offset + len(summaries) < total
        )
        
    except HTTPException:
        raise  # Re-raise HTTPException as-is
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get summaries: {str(e)}"
        )

@router.get("/search", response_model=List[WeeklySummaryPublic])
@weave.op()
@limiter.limit("10/minute")
async def search_summaries_route(
    query: str,
    request: Request,
    db: AsyncSession = Depends(get_session)
):
    """Search for summaries using vector similarity with prompt injection protection and query improvement."""
    try:
        # Check for prompt injection and improve query
        improved_query = await search_service.improve_search_query(query)
        
        # If query was sanitized to empty or too short, return empty results
        if not improved_query or len(improved_query.strip()) < 2:
            raise HTTPException(
                status_code=400,
                detail="Search query is invalid or too short"
            )
        
        # Perform vector search with improved query
        summaries = await summary_service.vector_search_week_summaries(
            session=db, 
            query_text=improved_query, 
            similarity_threshold=0.3
        )
        return summaries
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to search summaries: {str(e)}"
        )

@router.get("/stats/count", response_model=dict)
async def get_summary_count_route(db: AsyncSession = Depends(get_session)):
    """Get total count of weekly summaries."""
    try:
        count = await summary_service.get_count_of_summaries(session=db)
        return {"total_summaries": count}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get summary count: {str(e)}")

@router.get("/{summary_id}", response_model=WeeklySummaryPublic)
async def get_summary_by_id_route(summary_id: int, db: AsyncSession = Depends(get_session)):
    """Get a specific weekly summary by ID."""
    try:
        summary = await summary_service.get_weekly_summary_by_id(session=db, summary_id=summary_id)
        if not summary:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return summary
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get summary: {str(e)}")

@router.put("/{summary_id}", response_model=WeeklySummaryPublic)
async def update_summary_route(summary_id: int, summary_data: dict, db: AsyncSession = Depends(get_session)):
    """Update a weekly summary (regenerates embedding if content changed)."""
    try:
        summary = await summary_service.update_weekly_summary(session=db, summary_id=summary_id, summary_data=summary_data)
        if not summary:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return summary
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to update summary: {str(e)}")

@router.delete("/{summary_id}")
async def delete_summary_route(summary_id: int, db: AsyncSession = Depends(get_session)):
    """Delete a weekly summary."""
    try:
        success = await summary_service.delete_weekly_summary(session=db, summary_id=summary_id)
        if not success:
            raise HTTPException(status_code=404, detail="Weekly summary not found")
        return {"message": "Weekly summary deleted successfully"}
    except HTTPException: # Re-raise HTTPException directly
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to delete summary: {str(e)}")
